1. Activity Selection Problem

int maxMeetings(int start[], int end[], int n) {
    vector<pair<int, int>> v;
    for (int i = 0; i < n; i++) v.push_back({start[i], end[i]});
    sort(v.begin(), v.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
        return a.second < b.second;
    });
    int prev = 0;
    int ans = 0;
    for (int i = 0; i < n; i++)
        if (v[i].first > prev) {
            ans++;
            prev = v[i].second;
        }
    return ans;
}

-----------------------------------------------------
2. Job SequencingProblem

-----------------------------------------------------
3. Huffman Coding

-----------------------------------------------------
4. Water Connection Problem

vector<vector<int>> solve(int n, int p, vector<int> a, vector<int> b, vector<int> d) {
    vector<vector<int>> ans;
    vector<int> temp(20, 0);
    for (int i : a) temp[i]++;
    for (int i : b) temp[i]++;
    unordered_map<int, pair<int, int>> m;
    for (int i = 0; i < p; i++) m[a[i]] = {b[i], d[i]};
    for (int i = 1; i <= 20; i++) {
        if (temp[i] == 1 && m.find(i) != m.end()) {
            int x = i;
            int dia = INT_MAX;
            while (m.find(x) != m.end()) {
                dia = min(dia, m[x].second);
                x = m[x].first;
                m[i] = {x, dia};
            }
            ans.push_back({i, m[i].first, m[i].second});
        }
    }
    return ans;
}

-----------------------------------------------------
5. Fractional Knapsack Problem
O(N*logN) time, O(1) space : Greedy on value per unit weight.
double fractionalKnapsack(int W, Item arr[], int n)
{
    sort(arr,arr+n,[](const Item& a,const Item& b){
        return (double)a.value/a.weight > (double)b.value/b.weight;
    });
    int i=0;
    double ans=0;
    while(i<n && W){
        ans+=min(arr[i].weight,W)*(double)arr[i].value/arr[i].weight;
        W-=min(arr[i++].weight,W);
    }
    return ans;
}

-----------------------------------------------------
6. Greedy Algorithm to find Minimum number of Coins

-----------------------------------------------------
7. Maximum trains for which stoppage can be provided

-----------------------------------------------------
8. Minimum Platforms Problem

typedef pair<int, int> pi;
int findPlatform(int arr[], int dep[], int n) {
    vector<pi> v;
    for (int i = 0; i < n; i++) v.push_back(pi(arr[i], dep[i]));
    sort(v.begin(), v.end(), [](const pi& a, const pi& b) {
            return a.second < b.second;
    });
    int ans = 0;
    for (int i = 0; i < n; i++) {
        int temp = 1;
        for (int j = i + 1; j < n; j++) {
            if (v[j].first <= v[i].second) temp++;
        }
        ans = max(ans, temp);
        if (ans == n) return ans;
    }
    return ans;
}

-----------------------------------------------------
9. Buy Maximum Stocks if i stocks can be bought on i-th day

-----------------------------------------------------
10. Find the minimum and maximum amount to buy all N candies

vector<int> candyStore(int candies[], int N, int k)
{
    sort(candies,candies+N);
    int min=0,max=0;
    int n=N-1,i=0;
    while(i<=n){
        min+=candies[i++];
        n-=k;
    }
    i=N-1,n=0;
    while(i>=n){
        max+=candies[i--];
        n+=k;
    }
    return vector<int>({min,max});
}

-----------------------------------------------------
11. Minimize Cash Flow among a given set of friends who have borrowed money from each other

-----------------------------------------------------
12. Minimum Cost to cut a board into squares

-----------------------------------------------------
13. Check if it is possible to survive on Island

-----------------------------------------------------
14. Find maximum meetings in one room

-----------------------------------------------------
15. Maximum product subset of an array

-----------------------------------------------------
16. Maximize array sum after K negations

long long int maximizeSum(long long int a[], int n, int k)
{
    sort(a,a+n);
    long long int ans=accumulate(a,a+n,0LL);
    long long int mi=INT_MAX;
    int i=0;
    while(k--){
        if(a[i]<0) {
            mi=min(mi,a[i]*-1);
            ans-=2*a[i++];
        }
        else {
            mi=min(a[i],mi);
            ans-=2*mi;
            mi*=-1;
        }
    }
    return ans;
}

-----------------------------------------------------
17. Maximize the sum of arr[i]*i

-----------------------------------------------------
18. Maximum sum of absolute difference of an array

-----------------------------------------------------
19. Maximize sum of consecutive differences in a circular array

long long int maxSum(int arr[], int n)
{
    long long int ans=0;
    sort(arr,arr+n);
    int k=ceil(n/2);
    int t=0;
    for(int i=0;i<k;i++){
        ans+=abs(arr[n-1-t]-arr[i]);
        ans+=abs(arr[n-1-t]-arr[(i+1)%k]);
        t++;
    }
    return ans;
}

-----------------------------------------------------
20. Minimum sum of absolute difference of pairs of two arrays

-----------------------------------------------------
21. Program for Shortest Job First (or SJF) CPU Scheduling

-----------------------------------------------------
22. Program for Least Recently Used (LRU) Page Replacement algorithm

int pageFaults(int N, int C, int pages[]) {
    unordered_map<int, list<int>::iterator> m;
    list<int> mem;
    int ans = 0;
    for (int i = 0; i < N; i++) {
        if (m.find(pages[i]) != m.end())
            mem.erase(m[pages[i]]);
        else if (C)
            ans++, C--;
        else {
            m.erase(mem.front());
            mem.pop_front();
            ans++;
        }
        mem.push_back(pages[i]);
        m[pages[i]] = --mem.end();
    }
    return ans;
}

-----------------------------------------------------
23. Smallest subset with sum greater than all other elements

-----------------------------------------------------
24. Chocolate Distribution Problem

-----------------------------------------------------
25. DEFKIN -Defense of a Kingdom

-----------------------------------------------------
26. DIEHARD -DIE HARD

-----------------------------------------------------
27. GERGOVIA -Wine trading in Gergovia

-----------------------------------------------------
28. Picking Up Chicks

-----------------------------------------------------
29. CHOCOLA â€“Chocolate

-----------------------------------------------------
30. ARRANGE -Arranging Amplifiers

-----------------------------------------------------
31. K Centers Problem

-----------------------------------------------------
32. Minimum Cost of ropes

long long minCost(long long arr[], long long n) {
    long long int ans=0;
    priority_queue<long long int, vector<long long int>, greater<long long int> >q;
    for(int i=0;i<n;i++) q.push(arr[i]);
    while(q.size()!=1){
        long long int x=q.top();
        q.pop();
        long long int y=q.top();
        q.pop();
        q.push(x+y);
        ans+=x+y;
    }
    return ans;
}

-----------------------------------------------------
33. Find smallest number with given number of digits and sum of digits

-----------------------------------------------------
34. Rearrange characters in a string such that no two adjacent are same

-----------------------------------------------------
35. Find maximum sum possible equal sum of three stacks

-----------------------------------------------------
