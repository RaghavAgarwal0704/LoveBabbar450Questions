1. Write a Program to reverse the Linked List. (Both Iterative and recursive)

first solve using stack but then it uses extra data structure, next solve using recursion but here also extra space of stack call, finally solve iteratively.
ITERATIVE:(solved using 3 pointers, practice using 2 pointers using xor)
struct Node* reverseList(struct Node *head)
{
      struct Node* curr=head,*next=NULL,*prev=NULL;
      while(curr!=NULL)
      {
            next=curr->next;
            curr->next=prev;
            prev=curr;
            curr=next;
      }
      return prev;
}

RECURSIVE: pass 2 nodes to function prev and current node and make current->next = prev. Then recursive call the function with current node as prev node. And if current node is NULL return prev node
Node* reverseUtil(Node* pre,Node* head){
    if(!head) return pre;
    Node* next=head->next;
    head->next=pre;
    return reverseUtil(head,next);
}
Node *reverseList(Node *head)
{
    return reverseUtil(NULL,head);
}


----------------------------------------------------------------------
2. Reverse a Linked List in group of Given Size. [Very Imp]

struct node *reverseList(struct node *head, int k) {
    struct node *pre = NULL, *ptr = head, *temp = head;
    while (k-- && ptr) {
        temp = ptr->next;
        ptr->next = pre;
        pre = ptr;
        ptr = temp;
    }
    head->next = ptr;
    head = pre;
    return head;
}

struct node *reverse(struct node *head, int k) {
    struct node *temp = head;
    struct node *t1, *t2 = NULL;
    while (temp) {
        t1 = temp;
        temp = reverseList(temp, k);
        t2 ? t2->next = temp : head = temp;
        temp = t1->next;
        t2 = t1;
    }
    return head;
}

----------------------------------------------------------------------
3. Write a program to Detect loop in a linked list.

int detectloop(Node *head) {
    Node *slow = head;
    Node *fast = head;
    while (fast && fast->next) {
        fast = fast->next->next;
        slow = slow->next;
        if (fast == slow)
            return 1;
    }
    return 0;
}

----------------------------------------------------------------------
4. Write a program to Delete loop in a linked list.

----------------------------------------------------------------------
5. Find the starting point of the loop. 

----------------------------------------------------------------------
6. Remove Duplicates in a sorted Linked List.

Node *removeDuplicates(Node *head)
{
 Node* curr=head;
 while(curr&&curr->next){
     if(curr->data==curr->next->data)
     {
            Node *temp=curr->next->next;
            free(curr->next);
            curr->next=temp;
     }
     else curr=curr->next;
 }
 return head;
}

----------------------------------------------------------------------
7. Remove Duplicates in a Un-sorted Linked List.
3 methods.
(1) o(n^2) constant space:two loops - naive

void removeDuplicates(struct Node *start)
{
    struct Node *ptr1, *ptr2, *dup;
    ptr1 = start;
 
    /* Pick elements one by one */
    while (ptr1 != NULL && ptr1->next != NULL)
    {
        ptr2 = ptr1;
 
        /* Compare the picked element with rest
           of the elements */
        while (ptr2->next != NULL)
        {
            /* If duplicate then delete it */
            if (ptr1->data == ptr2->next->data)
            {
                /* sequence of steps is important here */
                dup = ptr2->next;
                ptr2->next = ptr2->next->next;
                delete(dup);
            }
            else /* This is tricky */
                ptr2 = ptr2->next;
        }
        ptr1 = ptr1->next;
    }
}

(2) o(nlogn) constant space (todo---merge sort on linked list)
    for this do merge sort in nlogn then apply the same method for removing duplicates from sorted list
    
(3) o(n) time ,o(n) space

void removeDuplicates(struct Node *start)
{
    // Hash to store seen values
    unordered_set<int> seen;
 
    /* Pick elements one by one */
    struct Node *curr = start;
    struct Node *prev = NULL;
    while (curr != NULL)
    {
        // If current value is seen before
        if (seen.find(curr->data) != seen.end())
        {
           prev->next = curr->next;
           delete (curr);
        }
        else
        {
           seen.insert(curr->data);
           prev = curr;
        }
        curr = prev->next;
    }
}

----------------------------------------------------------------------
8. Write a Program to Move the last element to Front in a Linked List.

void moveToFront(Node **head_ref)  
{  
    if (*head_ref == NULL || (*head_ref)->next == NULL)  
        return;  
  
    
    Node *secLast = NULL;  
    Node *last = *head_ref;  
    while (last->next != NULL)  
    {  
        secLast = last;  
        last = last->next;  
    }
    secLast->next = NULL;
    last->next = *head_ref;
    *head_ref = last;  
} 

----------------------------------------------------------------------
9. Add “1” to a number represented as a Linked List.

(1) Reversing the linked list then adding 1 to head and carry to next nodes and then reversing again.
Node *reverse(Node *head)
{
        Node *prev=NULL,*curr=head,*next=NULL;
        while(curr)
        {
            next=curr->next;
            curr->next=prev;
            prev=curr;
            curr=next;
        }
        return prev;
}
Node *util(Node *head)
{
       int carry=1,sum=0;
       Node* curr=head,*temp;
       while(curr)
       {
           sum=carry+curr->data;
           carry=sum>9?1:0;
           sum=sum%10;
           curr->data=sum;
           temp=curr;
           curr=curr->next;
       }
       if(carry)
       {
           temp->next=new Node(carry);
       }
       return head;
}
Node* addOne(Node *head) 
{
        return(reverse(util(reverse(head))));
}

(2) Backtracking approach : Reach the last node and increment by 1 and update carry. Then add carry to the nodes and update carry. 
Node* util(Node* head,int &carry){
        if(!head) return head;
        head->next=util(head->next,carry);
        head->data+=(head->next==NULL)?1:carry;
        carry=head->data/10;
        head->data%=10;
        return head;
    }
Node* addOne(Node *head) 
{
    int carry=0;
    head=util(head,carry);
    if(carry==1) {
        Node* temp=head;
        head=new Node(1);
        head->next=temp;
    }
    return head;
}
see: https://www.geeksforgeeks.org/add-one-to-a-number-represented-as-linked-list-set-2/?ref=rp
----------------------------------------------------------------------
10. Add two numbers represented by linked lists.

Node* reverseUtil(Node* pre,Node* head){
    if(!head) return pre;
    Node* next=head->next;
    head->next=pre;
    return reverseUtil(head,next);
}
Node *addTwoLists(Node *first, Node *second)
{
    int carry=0;
    Node* head=NULL;
    Node *ptr=head;
    while(first && second){
        int sum=first->data+second->data+carry;
        carry=sum/10;
        if(!head) head=new Node(sum%10),ptr=head;
        else ptr->next=new Node(sum%10),ptr=ptr->next;
        first=first->next;
        second=second->next;
    }
    while(first){
        int sum=first->data+carry;
        carry=sum/10;
        if(!head) head=new Node(sum%10),ptr=head;
        else ptr->next=new Node(sum%10),ptr=ptr->next;
        first=first->next;
    }
    while(second){
        int sum=second->data+carry;
        carry=sum/10;
        if(!head) head=new Node(sum%10),ptr=head;
        else ptr->next=new Node(sum%10),ptr=ptr->next;
        second=second->next;
    }
    if (carry) ptr->next = new Node(carry);
    return  reverseUtil(NULL,head);
}

----------------------------------------------------------------------
11. Intersection of two Sorted Linked List.

Node* findIntersection(Node* head1, Node* head2)
{
    Node* head=NULL;
    Node* ptr=head;
    while(head1 && head2){
        if(head1->data==head2->data) {
            if(!head) head=new Node(head1->data),ptr=head;
            else ptr->next=new Node(head1->data),ptr=ptr->next;
            head1=head1->next;
            head2=head2->next;
        }
        else{
            if(head1->data<head2->data) head1=head1->next;
            else head2=head2->next;
        }
    }
    return head;
}

----------------------------------------------------------------------
12. Intersection Point of two Linked Lists.

method 1: using two loops--naive time o(n*m) space o(1)

ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        while (headA != nullptr) {
            ListNode *pB = headB;
            while (pB != nullptr) {
                if (headA == pB) return headA;
                pB = pB->next;
            }
            headA = headA->next;
        }
        return nullptr;
}


method 2: using set--> time o(n+m) space o(n)

ListNode *getIntersectionNode(ListNode *head1, ListNode *head2) {
        unordered_set<ListNode*>s;
        while(head1){
            s.insert(head1);
            head1=head1->next;
        }
        while(head2){
            if(s.find(head2)!=s.end())return head2;
            head2=head2->next;
        }
        return NULL;
}

method 3: time o(m+n) space o(1)
one list is longer then other so first reach end of the shorter list next traverse move ahead the head of the longer list by that many nodes as there are extra nodes in that list. so now head1 and head2 both have same no of nodes...

int intersectPoint(Node *head1, Node *head2) {
    Node *t1 = head1, *t2 = head2;
    while (t1 && t2)
        t1 = t1->next, t2 = t2->next;

    while (t1) t1 = t1->next, head1 = head1->next;
    while (t2) t2 = t2->next, head2 = head2->next;
    while (head1 && head2) {
        if (head1 == head2) return head1->data;
        head1 = head1->next, head2 = head2->next;
    }
    return -1;
}

----------------------------------------------------------------------
13. Merge Sort For Linked lists.[Very Important]

----------------------------------------------------------------------
14. Quicksort for Linked Lists.[Very Important]

----------------------------------------------------------------------
15. Find the middle Element of a linked list.

(1) store all values in array and then return arr[n/2]--> space n , time n
(2) find length of linked list and then run till half the length and return--> time n, space 1 but two pass
(3) slow and fast pointer--> time n space 1 single pass

ListNode* middleNode(ListNode* head) 
{
        ListNode* slow=head;
        ListNode* fast=head;
        while(fast!=nullptr && fast->next!=nullptr)
        {
            slow=slow->next;
            fast=(fast->next)->next;
        }
        return slow;
}
----------------------------------------------------------------------
16. Check if a linked list is a circular linked list.

bool isCircular(Node *head)
{
   Node *curr=head->next;
   while(curr){
       if(curr==head)return 1;
       curr=curr->next;
   }
   return 0;
}

----------------------------------------------------------------------
17. Split a Circular linked list into two halves.



----------------------------------------------------------------------
18. Write a Program to check whether the Singly Linked list is a palindrome or not.

method 1: use stack--naive time o(n) space o(n)


method 2: time o(n) space o(1)

void reverse(Node **head){
    Node* curr=*head,*next=NULL,*prev=NULL;
      while(curr!=NULL)
      {
            next=curr->next;
            curr->next=prev;
            prev=curr;
            curr=next;
      }
      *head=prev;
}
bool isPalindrome(Node *head)
{
    //Your code here
    Node*curr=head;
    int n=0,t=0;
    while(curr){
        n=n*10+curr->data;
        curr=curr->next;
    }
    reverse(&head);
    curr=head;
    while(curr){
        t=t*10+curr->data;
        curr=curr->next;
    }
    reverse(&head);
    return t==n;
}

----------------------------------------------------------------------
19. Deletion from a Circular Linked List.

----------------------------------------------------------------------
20. Reverse a Doubly Linked list.

----------------------------------------------------------------------
21. Find pairs with a given sum in a DLL.

----------------------------------------------------------------------
22. Count triplets in a sorted DLL whose sum is equal to given value “X”.

----------------------------------------------------------------------
23. Sort a “k”sorted Doubly Linked list.[Very IMP]

----------------------------------------------------------------------
24. Rotate DoublyLinked list by N nodes.

----------------------------------------------------------------------
25. Rotate a Doubly Linked list in group of Given Size.[Very IMP]

----------------------------------------------------------------------
26. Can we reverse a linked list in less than O(n) ?

----------------------------------------------------------------------
27. Why Quicksort is preferred for. Arrays and Merge Sort for LinkedLists ?

----------------------------------------------------------------------
28. Flatten a Linked List

----------------------------------------------------------------------
29. Sort a LL of 0's, 1's and 2's

----------------------------------------------------------------------
30. Clone a linked list with next and random pointer

----------------------------------------------------------------------
31. Merge K sorted Linked list

----------------------------------------------------------------------
32. Multiply 2 no. represented by LL

----------------------------------------------------------------------
33. Delete nodes which have a greater value on right side

----------------------------------------------------------------------
34. Segregate even and odd nodes in a Linked List

----------------------------------------------------------------------
35. Program for n’th node from the end of a Linked List

----------------------------------------------------------------------
36. Find the first non-repeating character from a stream of characters

----------------------------------------------------------------------
