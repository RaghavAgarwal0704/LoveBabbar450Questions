1. Write a Program to reverse the Linked List. (Both Iterative and recursive)

first solve using stack but then it uses extra data structure, next solve using recursion but here also extra space of stack call, finally solve iteratively.
ITERATIVE:(solved using 3 pointers, practice using 2 pointers using xor)
struct Node* reverseList(struct Node *head)
{
      struct Node* curr=head,*next=NULL,*prev=NULL;
      while(curr!=NULL)
      {
            next=curr->next;
            curr->next=prev;
            prev=curr;
            curr=next;
      }
      return prev;
}

RECURSIVE: pass 2 nodes to function prev and current node and make current->next = prev. Then recursive call the function with current node as prev node. And if current node is NULL return prev node
Node* reverseUtil(Node* pre,Node* head){
    if(!head) return pre;
    Node* next=head->next;
    head->next=pre;
    return reverseUtil(head,next);
}
Node *reverseList(Node *head)
{
    return reverseUtil(NULL,head);
}


----------------------------------------------------------------------
2. Reverse a Linked List in group of Given Size. [Very Imp]

struct node *reverseList(struct node *head, int k) {
    struct node *pre = NULL, *ptr = head, *temp = head;
    while (k-- && ptr) {
        temp = ptr->next;
        ptr->next = pre;
        pre = ptr;
        ptr = temp;
    }
    head->next = ptr;
    head = pre;
    return head;
}

struct node *reverse(struct node *head, int k) {
    struct node *temp = head;
    struct node *t1, *t2 = NULL;
    while (temp) {
        t1 = temp;
        temp = reverseList(temp, k);
        t2 ? t2->next = temp : head = temp;
        temp = t1->next;
        t2 = t1;
    }
    return head;
}

----------------------------------------------------------------------
3. Write a program to Detect loop in a linked list.

int detectloop(Node *head) {
    Node *slow = head;
    Node *fast = head;
    while (fast && fast->next) {
        fast = fast->next->next;
        slow = slow->next;
        if (fast == slow)
            return 1;
    }
    return 0;
}

----------------------------------------------------------------------
4. Write a program to Delete loop in a linked list.

----------------------------------------------------------------------
5. Find the starting point of the loop. 

----------------------------------------------------------------------
6. Remove Duplicates in a sorted Linked List.

Node *removeDuplicates(Node *head)
{
 Node* curr=head;
 while(curr&&curr->next){
     if(curr->data==curr->next->data)
     {
            Node *temp=curr->next->next;
            free(curr->next);
            curr->next=temp;
     }
     else curr=curr->next;
 }
 return head;
}

----------------------------------------------------------------------
7. Remove Duplicates in a Un-sorted Linked List.
3 methods.
(1) o(n^2) constant space:two loops - naive

void removeDuplicates(struct Node *start)
{
    struct Node *ptr1, *ptr2, *dup;
    ptr1 = start;
 
    /* Pick elements one by one */
    while (ptr1 != NULL && ptr1->next != NULL)
    {
        ptr2 = ptr1;
 
        /* Compare the picked element with rest
           of the elements */
        while (ptr2->next != NULL)
        {
            /* If duplicate then delete it */
            if (ptr1->data == ptr2->next->data)
            {
                /* sequence of steps is important here */
                dup = ptr2->next;
                ptr2->next = ptr2->next->next;
                delete(dup);
            }
            else /* This is tricky */
                ptr2 = ptr2->next;
        }
        ptr1 = ptr1->next;
    }
}

(2) o(nlogn) constant space (todo---merge sort on linked list)
    for this do merge sort in nlogn then apply the same method for removing duplicates from sorted list
    
(3) o(n) time ,o(n) space

void removeDuplicates(struct Node *start)
{
    // Hash to store seen values
    unordered_set<int> seen;
 
    /* Pick elements one by one */
    struct Node *curr = start;
    struct Node *prev = NULL;
    while (curr != NULL)
    {
        // If current value is seen before
        if (seen.find(curr->data) != seen.end())
        {
           prev->next = curr->next;
           delete (curr);
        }
        else
        {
           seen.insert(curr->data);
           prev = curr;
        }
        curr = prev->next;
    }
}

----------------------------------------------------------------------
8. Write a Program to Move the last element to Front in a Linked List.

void moveToFront(Node **head_ref)  
{  
    if (*head_ref == NULL || (*head_ref)->next == NULL)  
        return;  
  
    
    Node *secLast = NULL;  
    Node *last = *head_ref;  
    while (last->next != NULL)  
    {  
        secLast = last;  
        last = last->next;  
    }
    secLast->next = NULL;
    last->next = *head_ref;
    *head_ref = last;  
} 

----------------------------------------------------------------------
9. Add “1” to a number represented as a Linked List.

(1) Reversing the linked list then adding 1 to head and carry to next nodes and then reversing again.
Node *reverse(Node *head)
{
        Node *prev=NULL,*curr=head,*next=NULL;
        while(curr)
        {
            next=curr->next;
            curr->next=prev;
            prev=curr;
            curr=next;
        }
        return prev;
}
Node *util(Node *head)
{
       int carry=1,sum=0;
       Node* curr=head,*temp;
       while(curr)
       {
           sum=carry+curr->data;
           carry=sum>9?1:0;
           sum=sum%10;
           curr->data=sum;
           temp=curr;
           curr=curr->next;
       }
       if(carry)
       {
           temp->next=new Node(carry);
       }
       return head;
}
Node* addOne(Node *head) 
{
        return(reverse(util(reverse(head))));
}

(2) Backtracking approach : Reach the last node and increment by 1 and update carry. Then add carry to the nodes and update carry. 
Node* util(Node* head,int &carry){
        if(!head) return head;
        head->next=util(head->next,carry);
        head->data+=(head->next==NULL)?1:carry;
        carry=head->data/10;
        head->data%=10;
        return head;
    }
Node* addOne(Node *head) 
{
    int carry=0;
    head=util(head,carry);
    if(carry==1) {
        Node* temp=head;
        head=new Node(1);
        head->next=temp;
    }
    return head;
}
see: https://www.geeksforgeeks.org/add-one-to-a-number-represented-as-linked-list-set-2/?ref=rp
----------------------------------------------------------------------
10. Add two numbers represented by linked lists.


----------------------------------------------------------------------
11. Intersection of two Sorted Linked List.

----------------------------------------------------------------------
12. Intersection Point of two Linked Lists.

----------------------------------------------------------------------
13. Merge Sort For Linked lists.[Very Important]

----------------------------------------------------------------------
14. Quicksort for Linked Lists.[Very Important]

----------------------------------------------------------------------
15. Find the middle Element of a linked list.

(1) store all values in array and then return arr[n/2]--> space n , time n
(2) find length of linked list and then run till half the length and return--> time n, space 1 but two pass
(3) slow and fast pointer--> time n space 1 single pass

ListNode* middleNode(ListNode* head) 
{
        ListNode* slow=head;
        ListNode* fast=head;
        while(fast!=nullptr && fast->next!=nullptr)
        {
            slow=slow->next;
            fast=(fast->next)->next;
        }
        return slow;
}
----------------------------------------------------------------------
16. Check if a linked list is a circular linked list.

----------------------------------------------------------------------
17. Split a Circular linked list into two halves.

----------------------------------------------------------------------
18. Write a Program to check whether the Singly Linked list is a palindrome or not.

----------------------------------------------------------------------
19. Deletion from a Circular Linked List.

----------------------------------------------------------------------
20. Reverse a Doubly Linked list.

----------------------------------------------------------------------
21. Find pairs with a given sum in a DLL.

----------------------------------------------------------------------
22. Count triplets in a sorted DLL whose sum is equal to given value “X”.

----------------------------------------------------------------------
23. Sort a “k”sorted Doubly Linked list.[Very IMP]

----------------------------------------------------------------------
24. Rotate DoublyLinked list by N nodes.

----------------------------------------------------------------------
25. Rotate a Doubly Linked list in group of Given Size.[Very IMP]

----------------------------------------------------------------------
26. Can we reverse a linked list in less than O(n) ?

----------------------------------------------------------------------
27. Why Quicksort is preferred for. Arrays and Merge Sort for LinkedLists ?

----------------------------------------------------------------------
28. Flatten a Linked List

----------------------------------------------------------------------
29. Sort a LL of 0's, 1's and 2's

----------------------------------------------------------------------
30. Clone a linked list with next and random pointer

----------------------------------------------------------------------
31. Merge K sorted Linked list

----------------------------------------------------------------------
32. Multiply 2 no. represented by LL

----------------------------------------------------------------------
33. Delete nodes which have a greater value on right side

----------------------------------------------------------------------
34. Segregate even and odd nodes in a Linked List

----------------------------------------------------------------------
35. Program for n’th node from the end of a Linked List

----------------------------------------------------------------------
36. Find the first non-repeating character from a stream of characters

----------------------------------------------------------------------
