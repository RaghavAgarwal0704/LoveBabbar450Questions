1. Reverse the array

void rvereseArray(int arr[], int start, int end)
{
    if (start >= end)
    return;
     
    int temp = arr[start]; 
    arr[start] = arr[end];
    arr[end] = temp;
     
    // Recursive Function calling
    rvereseArray(arr, start + 1, end - 1); 
}     
----------------------------------
2. Find max and min in array

----------------------------------
3. Find Kth max and min in array

----------------------------------
4. Array contains 0,1,2 only. Sort without any algo.

void sort012(int a[], int arr_size) 
{ 
    int lo = 0; 
    int hi = arr_size - 1; 
    int mid = 0; 
  
    // Iterate till all the elements 
    // are sorted 
    while (mid <= hi) { 
        switch (a[mid]) { 
  
        // If the element is 0 
        case 0: 
            swap(a[lo++], a[mid++]); 
            break; 
  
        // If the element is 1 . 
        case 1: 
            mid++; 
            break; 
  
        // If the element is 2 
        case 2: 
            swap(a[mid], a[hi--]); 
            break; 
        } 
    } 
} 

---------------------------------------------------
5. Move all negative elements to one side.

(i) Not in-place method(o(n))

void shift(int arr[],int left,int right){
  while(left<=right){
  if(arr[left]<0){
    if(arr[right]>0){left++;right--;}
    else left++;
  }
  else{
    if(arr[right]>0)right--;
    else{
      swap(arr[left++],arr[right--]);
    }
  }
 }
}

(ii)in-place method (o(n),constant space)

void RearrangePosNeg(int arr[], int n)
{
    int i = 0;
    int j = n - 1;
    while (true) {
        // Loop until arr[i] < 0 and
        // still inside the array
        while (arr[i] < 0 && i < n)
            i++;
 
        // Loop until arr[j] > 0 and
        // still inside the array
        while (arr[j] > 0 && j >= 0)
            j--;
 
        // if i is less than j
        if (i < j) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
        else
            break;
    }
}

--------------------------------------------------
6. Union and intersection of two sorted arrays.

use map: time=m+n, space=m+n
for constant space: sort and then proceed (mlogm+nlogn)
code: https://www.geeksforgeeks.org/find-union-and-intersection-of-two-unsorted-arrays/

--------------------------------------------------
7. Cyclically rotate array by one

void rotate(int arr[], int n) 
{ 
    int x = arr[n - 1], i; 
    for (i = n - 1; i > 0; i--) 
    arr[i] = arr[i - 1];  
    arr[0] = x; 
}

what if want to cyclically rotate by some value d:

REVERSAL ALGORITHM
Let the array be arr[] = [1, 2, 3, 4, 5, 6, 7], d =2 and n = 7 
A = [1, 2] and B = [3, 4, 5, 6, 7] 
 

Reverse A, we get ArB = [2, 1, 3, 4, 5, 6, 7]
Reverse B, we get ArBr = [2, 1, 7, 6, 5, 4, 3]
Reverse all, we get (ArBr)r = [3, 4, 5, 6, 7, 1, 2]

void reverseArray(int arr[], int start, int end) 
{ 
    while (start < end) { 
        int temp = arr[start]; 
        arr[start] = arr[end]; 
        arr[end] = temp; 
        start++; 
        end--; 
    } 
} 
  
/* Function to left rotate arr[] of size n by d */
void leftRotate(int arr[], int d, int n) 
{ 
    if (d == 0) 
        return; 
    // in case the rotating factor is 
    // greater than array length 
    d = d % n; 
  
    reverseArray(arr, 0, d - 1); 
    reverseArray(arr, d, n - 1); 
    reverseArray(arr, 0, n - 1); 
} 

--------------------------------------------------
8. Largest sum contiguous subarray

int maxSubarraySum(int arr[], int n) {
    int sum = 0, max_sum = 0, max_ele = INT_MIN;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
        if (sum < 0) sum = 0;
        max_sum = max(sum, max_sum);
        max_ele = max(max_ele, arr[i]);
    }
    return max_sum ? max_sum : max_ele;
}

--------------------------------------------------
9. Minimise the maximize difference between heights.

---------------------------------------------------
10. Minimum no of jumps to reach array end.

int minJumps(int arr[], int n){
    if(n<=1) return 0;
    int i=0,j=0;
    for(int k=0;k<n;k++){
        int far=0;
        for(int w=i;w<=j;w++){
            if(w+arr[w]>=n-1) return k+1;
            far=max(far,arr[w]+w);
        }
        i=j+1;
        j=far;
    }
    return -1;      
}

---------------------------------------------------
11. Duplicate in an array of n+1 integers.

can use another array/vector => linear time but non-constant space
for constant space use Floyd's tortoise and hare(cycle detection) =>linear time constant space
code: https://leetcode.com/problems/find-the-duplicate-number/solution/

---------------------------------------------------
12. merge two sorted arrays without extra space.

---------------------------------------------------
13. KADANE'S ALGORITHM

int maxSubarraySum(int arr[], int n) {
    int sum = 0, max_sum = 0, max_ele = INT_MIN;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
        if (sum < 0) sum = 0;
        max_sum = max(sum, max_sum);
        max_ele = max(max_ele, arr[i]);
    }
    return max_sum ? max_sum : max_ele;
}

---------------------------------------------------
14. Merge intervals

vector<vector<int>> merge(vector<vector<int>>& intervals) {
    sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b) {
        return a[0] < b[0];
    });
    vector<vector<int>> ans;
    int last = INT_MIN;
    for (auto vi : intervals) {
        if (vi[0] > last)
            ans.push_back(vi);
        else
            ans.back()[1] = max(vi[1], last);
        last = max(last, vi[1]);
    }
    return ans;
}

--------------------------------------------------
15. Next permutation

--------------------------------------------------
16. Count inversion.

--------------------------------------------------
17. Best time to buy and sell stock.

int maxProfit(vector<int>& prices) {
    int ans=0;
    int minPrice=INT_MAX;
    for(int i:prices){
        if(i<minPrice) minPrice=i;
        else if(i-minPrice>ans) ans=i-minPrice;
    }
    return ans;
}

--------------------------------------------------
18. Find all pair of integers in array whose sum equal to given number.

int getPairsCount(int arr[], int n, int k) {
    // code here
    unordered_map<int,int>m;
    int ans=0;
    m[arr[0]]++;
    for(int i=1;i<n;i++){
        if(m[k-arr[i]]) ans+=m[k-arr[i]];
        m[arr[i]]++;
    }
    return ans;
}

---------------------------------------------------------------------
19. common element in 3 sorted arrays.

1) Naīve method : using O(n1+n2) space and O(n1+n2+n3) time
vector <int> commonElements (int A[], int B[], int C[], int n1, int n2, int n3)
{
    unordered_map<int,int>m1;
    unordered_map<int,int>m2;
    for(int i=0;i<n1;i++) m1[A[i]]++;
    for(int i=0;i<n2;i++) m2[B[i]]++;
    vector<int>ans;
    for(int i=0;i<n3;i++)
        if(m1[C[i]] && m2[C[i]]) if(!ans.size()|| ans.back()!=C[i]) ans.push_back(C[i]);
    return ans;
}

2) Better method : using O(1) space and O(n1+n2+n3) time
vector <int> commonElements (int A[], int B[], int C[], int n1, int n2, int n3)
{
    int i=0,j=0,k=0;
    vector<int>ans;
    while(i<n1 && j<n2 && k<n3){
        if(A[i]==B[j] && B[j]==C[k]) 
            if(!ans.size() || ans.back()!=A[i]) 
                ans.push_back(A[i]);
        
        int x=min(A[i],min(B[j],C[k]));
        if(A[i]==x) i++;
        else if(B[j]==x) j++;
        else k++;
    }
    return ans;
}

------------------------------------------------------------------
20. rearrange array with alternate positive and negative with o(1) extra space.

1) Naīve appraoch : O(n) space, O(n) time.
void rearrange(int arr[], int n) {
    vector<int> p;
    vector<int> neg;
    for (int i = 0; i < n; i++)
        if (arr[i] >= 0)
            p.push_back(arr[i]);
        else
            neg.push_back(arr[i]);
    int l = 0, r = 0;
    for (int i = 0; i < n; i++) {
        if (i & 1)
            arr[i] = l < neg.size() ? neg[l++] : p[r++];
        else
            arr[i] = r < p.size() ? p[r++] : neg[l++];
    }
}
2) Efficient approach: O(1) space, ?? time
void rearrange(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        int j = i;
        if (i & 1 && arr[i] >= 0)
            for (; j < n; j++) 
                if (arr[j] < 0) break;
            
        else if (!(i & 1) && arr[i] < 0)
            for (; j < n; j++) 
                if (arr[j] >= 0) break;

        if (j > i && j < n) {
            int temp = arr[j];
            while (j > i) arr[j--] = arr[j - 1];
            arr[i] = temp;
        }
    }
}
-----------------------------------------------------------------------------
21. find if there any subarray with sum equal to 0.

bool subArrayExists(int arr[], int n)
{
    for(int i=1;i<n;i++) arr[i]+=arr[i-1];
    unordered_map<int,int>m;
    for(int i=0;i<n;i++){
        if(arr[i]==0 || m[arr[i]]) return true;
        m[arr[i]]++;
    }
    return false;
}

----------------------------------------------------------
22. facorial of a large number.

vector<int> factorial(int N){
    vector<int>ans({1});
    for(int i=2;i<=N;i++){
        int carry=0;
        for(int &j:ans){
            long long int x=j*i + carry;
            j=x%10;
            carry=x/10;
        }
        string s=to_string(carry);
        reverse(s.begin(),s.end());
        for(char c:s) ans.push_back(c-'0');
    }
    reverse(ans.begin(),ans.end());
    int i=0;
    while(i<ans.size() && ans[i]==0) i++;
    return vector<int>(ans.begin()+i,ans.end());
}

----------------------------------------------------------
23. Maximum product subarray.

----------------------------------------------------------
24. longest consecutive subsequence.

----------------------------------------------------------
25. array size n and number k, find all elements that appear more than n/k times.

--------------------------------------------------------------------------------
26. maximum profit by buying and selling a share atmost twice.

--------------------------------------------------------------------------------
27. find if an array is subset of another array.

-------------------------------------------------------------------------------
28. find triplet that sum to a given value.

--------------------------------------------------------------------------------
29. trapping rain water problem.

-------------------------------------------------------------------------------
30. chocolate distribution problem.

-------------------------------------------------------------------------------
31. smallest subarray with sum greater than a given value.

-------------------------------------------------------------------------------
32. three way partitioning of an array around a given value.

-------------------------------------------------------------------------------
33. Minimum swaps required bring elements less equal K together

-------------------------------------------------------------------------------
34. Minimum no. of operations required to make an array palindrome

------------------------------------------------------------------------------
35. Median of 2 sorted arrays of equal size

------------------------------------------------------------------------------
36. Median of 2 sorted arrays of different size

-----------------------------------------------------------------------------
