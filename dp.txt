1. Coin ChangeProblem
(1) Naīve Recursive method : 
int util(int N,int arr[],int sum){
    if(N==0 ) return sum==0;
    if(N==0 && sum!=0) return 0;    
    if(arr[N-1]<=sum) 
        return util(N-1,arr,sum-arr[N-1]) || util(N-1,arr,sum);
    
    return util(N-1,arr,sum);
}
int equalPartition(int N, int arr[])
{
    int sum=0;
    for(int i=0;i<N;i++) sum+=arr[i];
    if(sum&1 || N<=1 ) return 0;
    return util(N,arr,sum/2);
}

(2) Recursive with memoization : O(m*n) space, O(n*m) time;
long long int util(int S[], int m, int n) {
    if (n == 0 || m == 0) return 0;
    if (dp[n][m] != -1) return dp[n][m];
    if (S[m - 1] <= n) {
        if (S[m - 1] == n) dp[n][m] = util(S, m - 1, n) + 1LL;
        else dp[n][m] = util(S, m, n - S[m - 1]) + util(S, m - 1, n);
    } else
        dp[n][m] = util(S, m - 1, n);
    return dp[n][m];
}
long long int count(int S[], int m, int n) {
    dp = vector<vector<long long>>(n + 1, vector<long long>(m + 1, -1));
    return util(S, m, n);
}

(3) Iterative(top-down) : O(m*n) space, O(n*m) time;
vector<vector<long long>> dp;
long long int count(int S[], int m, int n) {
    vector<vector<long long>> dp(n + 1, vector<long long>(m + 1, 0));
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            dp[i][j] = dp[i][j - 1];
            if (S[j - 1] == i)
                dp[i][j] = dp[i][j - 1] + 1LL;
            else if (S[j - 1] < i)
                dp[i][j] = dp[i - S[j - 1]][j] + dp[i][j - 1];
        }
    }
    return dp[n][m];
}

----------------------------------------------
2. Knapsack Problem
(1) Naīve Recursive method : 
int knapSack(int W, int wt[], int val[], int n) {
    if (n <= 0 || W <= 0) return 0;
    if (wt[n - 1] <= W)
        return max(val[n - 1] + util(W - wt[n - 1], wt, val, n - 1), util(W, wt, val, n - 1));
    return util(W, wt, val, n - 1);
}

(2) Recursive method with memoization : O(n*W) space, O(n*W) time
vector<vector<int>> dp;
int util(int W, int wt[], int val[], int n) {
    if (n <= 0 || W <= 0) return 0;
    if (dp[W][n] != -1) return dp[W][n];
    if (wt[n - 1] <= W)
        dp[W][n] = max(val[n - 1] + util(W - wt[n - 1], wt, val, n - 1), util(W, wt, val, n - 1));
    else
        dp[W][n] = util(W, wt, val, n - 1);
    return dp[W][n];
}
int knapSack(int W, int wt[], int val[], int n) {
    dp = vector<vector<int>>(W + 1, vector<int>(n + 1, -1));
    return util(W, wt, val, n);
}

(3) Iterative method : O(n*W) space, O(n*W) time
int knapSack(int W, int wt[], int val[], int n) {
    vector<vector<int>> dp(W + 1, vector<int>(n + 1, 0));
    for (int i = 1; i <= W; i++)
        for (int j = 1; j <= n; j++) {
            if (i >= wt[j - 1])
                dp[i][j] = max(val[j - 1] + dp[i - wt[j - 1]][j - 1], dp[i][j - 1]);
            else
                dp[i][j] = dp[i][j - 1];
        }
    return dp[W][n];
}

----------------------------------------------
3. Binomial CoefficientProblem

----------------------------------------------
4. Permutation CoefficientProblem

----------------------------------------------
5. Program for nth Catalan Number

----------------------------------------------
6. Matrix Chain Multiplication 

----------------------------------------------
7. Edit Distance

----------------------------------------------
8. Subset Sum Problem

----------------------------------------------
9. Friends Pairing Problem

----------------------------------------------
10. Gold Mine Problem

----------------------------------------------
11. Assembly Line SchedulingProblem

----------------------------------------------
12. Painting the Fenceproblem

----------------------------------------------
13. Maximize The Cut Segments

----------------------------------------------
14. Longest Common Subsequence

----------------------------------------------
15. Longest Repeated Subsequence

----------------------------------------------
16. Longest Increasing Subsequence

(1) Naīve approach : O(N^2) time and O(N) space
int longestSubsequence(int n, int a[])
{
    vector<int>dp(n+1,1);
    for(int i=1;i<n;i++){
        int m=INT_MIN;
        for(int j=0;j<i;j++) if(a[i]>a[j])m=max(m,dp[j]);
        dp[i]=(m==INT_MIN)?1:m+1;
    }
    return *max_element(dp.begin(),dp.end());
}

(2) Better method : O(N*logN) time and O(N) space
int longestSubsequence(int n, int a[])
{
    
    vector<int>ans({a[0]});
    for(int i=1;i<n;i++){
        int ind=lower_bound(ans.begin(),ans.end(),a[i])-ans.begin();   
        if(ind==ans.size()) ans.push_back(a[i]);
        else ans[ind]=a[i];
    }
    return ans.size();
}

----------------------------------------------
17. Space Optimized Solution of LCS

----------------------------------------------
18. LCS (Longest Common Subsequence) of three strings

----------------------------------------------
19. Maximum Sum Increasing Subsequence

----------------------------------------------
20. Count all subsequences having product less than K

----------------------------------------------
21. Longest subsequence such that difference between adjacent is one

----------------------------------------------
22. Maximum subsequence sum such that no three are consecutive

----------------------------------------------
23. Egg Dropping Problem

----------------------------------------------
24. Maximum Length Chain of Pairs

----------------------------------------------
25. Maximum size square sub-matrix with all 1s

----------------------------------------------
26. Maximum sum of pairs with specific difference

----------------------------------------------
27. Min Cost PathProblem

----------------------------------------------
28. Maximum difference of zeros and ones in binary string

----------------------------------------------
29. Minimum number of jumps to reach end

----------------------------------------------
30. Minimum cost to fill given weight in a bag

----------------------------------------------
31. Minimum removals from array to make max –min <= K

----------------------------------------------
32. Longest Common Substring

----------------------------------------------
33. Count number of ways to reacha given score in a game

----------------------------------------------
34. Count Balanced Binary Trees of Height h

----------------------------------------------
35. LargestSum Contiguous Subarray [V>V>V>V IMP ]

----------------------------------------------
36. Smallest sum contiguous subarray

----------------------------------------------
37. Unbounded Knapsack (Repetition of items allowed)

----------------------------------------------
38. Word Break Problem

----------------------------------------------
39. Largest Independent Set Problem

----------------------------------------------
40. Partition problem

----------------------------------------------
41. Longest Palindromic Subsequence

----------------------------------------------
42. Count All Palindromic Subsequence in a given String

----------------------------------------------
43. Longest Palindromic Substring

----------------------------------------------
44. Longest alternating subsequence

----------------------------------------------
45. Weighted Job Scheduling

----------------------------------------------
46. Coin game winner where every player has three choices

----------------------------------------------
47. Count Derangements (Permutation such that no element appears in its original position) [ IMPORTANT ]

----------------------------------------------
48. Maximum profit by buying and selling a share at most twice [ IMP ]

----------------------------------------------
49. Optimal Strategy for a Game

----------------------------------------------
50. Optimal Binary Search Tree

----------------------------------------------
51. Palindrome PartitioningProblem

----------------------------------------------
52. Word Wrap Problem

----------------------------------------------
53. Mobile Numeric Keypad Problem [ IMP ]

----------------------------------------------
54. Boolean Parenthesization Problem

----------------------------------------------
55. Largest rectangular sub-matrix whose sum is 0

----------------------------------------------
56. Largest area rectangular sub-matrix with equal number of 1’s and 0’s [ IMP ]

----------------------------------------------
57. Maximum sum rectangle in a 2D matrix

----------------------------------------------
58. Maximum profit by buying and selling a share at most k times

----------------------------------------------
59. Find if a string is interleaved of two other strings

----------------------------------------------
60. Maximum Length of Pair Chain

----------------------------------------------
